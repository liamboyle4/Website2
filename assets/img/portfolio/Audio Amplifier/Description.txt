This was a semester long project that I worked on with one other teammate. This project was built using only basic circuit components, breadboards, an Arduino Uno, and a small OLED display. We were tasked with creating a three band graphic equalizer, amplifying that signal using a class-D amplifier, filtering out the high frequency components, and finally displaying the strength of each band using a spectrogram on the OLED display. 

Graphic Equalizer
We designed our graphic equalizer by creating three filters and summing their outputs twice: once at 0 degrees and once at 180 degrees, with the original input using an LF356n op-amp. Potentiometers were used to adjust the difference of each filter's summing component, and the filter outputs canceled out at the potentiometer's center point. This allowed for a clean output regardless of how the bands were adjusted, as opposed to simply summing the filter outputs, which would result in unwanted drops or peaks in the frequency response. We chose the center frequencies of the bass, mid-range, and treble bands to be 115 Hz, 1 kHz, and 6.5 kHz, respectively.

I was overall happy with the results of our equalizer. For each band, it achieved a maximum cut of about -4.5 dB, a maximum boost of about 3 dB, and stayed at nearly 0 dB with the potentiometer in the neutral position. Since this equalizer used standard op-amps, it could not drive the load by itself, which required us to design a class-D amplifier.

Class-D Amp
The overall design plan of our class-D amplifier was to pulse-width modulate the input, send the PWM signal through a switching stage of MOSFETs, and finally filter out the high-frequency components. This design ended up being much more involved than we anticipated, especially with the limited equipment we were permitted to use.

First, we needed to create a triangular carrier frequency that would be compared to the input and would result in a PWM signal. We wanted the carrier frequency to be as high as possible so that most of the audible range (20 Hz - 20 kHz) would be unaffected by the low-pass filter. The Arduino Uno was the source of this frequency, and unfortunately, it is only able to generate a 1 kHz square wave by default. To fix this, we set the prescaler of the output pin's timer to 1, which essentially gave us the Arduino's system clock at about 60 kHz. This signal was unipolar, so we scaled it to -5V to 5V using a comparator op-amp. Next, knowing that the integral of a square wave is a triangle wave, we built a simple op-amp integrator to get our final triangular carrier wave. Finally, we sent this wave and the input into a comparator op-amp to get our 60 kHz PWM signal.

For the switching stage, we tried to keep the device characteristics as close as possible by using two NMOSs instead of an NMOS and PMOS. This now requires a second inverted PWM signal, so we simply duplicated the comparator circuit but switched the input terminals. The devices were still slightly mismatched since we were using discrete components, and this affected the timing of the switching, causing a large amount of shoot-through current, poor power efficiency, and distortion in the output. To combat this, we clamped the triangle wave going into the inverted comparator by -1V in order to add dead time; a period where both PWM signals are low and both NMOSs are off.

Finally, we had our amplified output with low distortion and only about 25mA of shoot-through current. We built a low-pass filter with a break frequency of 16 kHz that achieved an attenuation of around -33 dB at our carrier frequency, 60 kHz. The op-amps we had could not drive the current required by the load, and we only needed negative or zero gain, so we decided to use a passive filter.

Spectrogram
The final part of this project involved programming a spectrogram on our Arduino to display the frequency response of the output on our small OLED screen. The simplest approach would have been to display the strength of the signals from the three filters. However, we opted for a more thorough approach and performed a real-time Fourier analysis. After testing our Arduino, we found that it can read our output about 9000 times per second. According to Nyquist's theorem, this meant that we could only accurately analyze up to 4.5 kHz. We utilized the “fix_fft.h” Arduino library to perform the Fourier analysis, which returns two arrays of 128 samples, one with real values and one with imaginary values. We then divided the first 64 samples into three sections (since the other 64 samples are beyond 4.5 kHz) and plotted the averages of the magnitudes of the samples in each section. This process resulted in our three-band spectrogram, which is displayed below.

